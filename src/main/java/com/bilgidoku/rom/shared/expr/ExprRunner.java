/* Generated By:JavaCC: Do not edit this line. ExprRunner.java */
package com.bilgidoku.rom.shared.expr;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.bilgidoku.rom.shared.Att;
import com.bilgidoku.rom.shared.RunException;
import com.bilgidoku.rom.shared.json.JSONArray;
import com.bilgidoku.rom.shared.json.JSONBoolean;
import com.bilgidoku.rom.shared.json.JSONNull;
import com.bilgidoku.rom.shared.json.JSONNumber;
import com.bilgidoku.rom.shared.json.JSONObject;
import com.bilgidoku.rom.shared.json.JSONString;
import com.bilgidoku.rom.shared.json.JSONValue;
import com.bilgidoku.rom.shared.state.Scope;
import com.bilgidoku.rom.shared.json.JSONParser;

public class ExprRunner implements ExprRunnerConstants {

  private Scope scope;

  public ExprRunner scope(Scope scope)
  {
    this.scope=scope;
    return this;
  }

  public static List<MyLiteral> build(String expression,Scope scope) throws RunException
  {
        if (expression == null) {
                return null;
        }

        try {
                return new ExprRunner(new StringCharacterStream(expression)).scope(scope).Tree();
        } catch (ParseException pe) {
                throw new RunException("Expression parse exception:", pe).expr(expression);
        }
  }

  private MyLiteral trans(MyLiteral n) throws RunException {
                String s = n.getString();
                return new MyLiteral(scope.getTrans(s));
  }

  private MyLiteral urlencode(MyLiteral n) throws RunException {
                return n.urlEncode();
  }

  private MyLiteral money(MyLiteral n) throws RunException {
                return n.money();
  }


   private MyLiteral getIdentifier(String image) throws RunException
  {
        return scope.getValue(image, true);
  }

  private MyLiteral retVal(JSONValue val) {

           if (val == null || val.isNull() != null)
                        return new MyLiteral();

          JSONNumber num=val.isNumber();
          if(num!=null){
                      try{
                          MyLiteral k = new MyLiteral((double)num.doubleValue());
                          return k;
                  }catch(ClassCastException cce){
                  }
          }

          JSONBoolean bol=val.isBoolean();
          if(bol!=null){
                  return new MyLiteral(bol.booleanValue());
          }

          JSONString str=val.isString();
          if(str!=null){
                  return new MyLiteral(str.stringValue());
          }
          JSONObject jsonObject = val.isObject();
          if (jsonObject != null) {
                return new MyLiteral(jsonObject);
          }

          JSONArray jsonArray = val.isArray();
        return new MyLiteral(jsonArray);
}

  private MyLiteral getProperty(String name, List propList,List aList) throws ParseException, RunException
  {
                JSONValue val  = scope.getJson(name, true);
                if(val==null){
                        return new MyLiteral();
                }

        for (int i = 0; i < propList.size(); i++) {
                String p = (String) propList.get(i);
                if (p != null && val != null) {
                        JSONObject valo = val.isObject();
                        if(valo==null){
                                        return new MyLiteral();
                        }
                        val = valo.opt(p);
                        continue;
                }
                Integer ind = (Integer) aList.get(i);
                if(val==null)
                        return new MyLiteral();
                JSONArray vala = val.isArray();
                if(vala==null){
                                return new MyLiteral();
                }
                val = vala.get(ind);
        }

        return retVal(val);
  }

  final private List<MyLiteral> Tree() throws ParseException, RunException {
                                                       MyLiteral l;List<MyLiteral> s=new ArrayList<MyLiteral>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NORMAL_DEFAULT:
    case ESCAPED_DEFAULT:
      l = Text();
                                s.add(l);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_EVAL_DYNAMIC:
    case START_EVAL_DEFERRED:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_EVAL_DYNAMIC:
        label_1:
        while (true) {
          l = Dynamic();
                                s.add(l);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NORMAL_DEFAULT:
          case ESCAPED_DEFAULT:
            l = Text();
                                s.add(l);
            break;
          default:
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case START_EVAL_DYNAMIC:
            ;
            break;
          default:
            break label_1;
          }
        }
        break;
      case START_EVAL_DEFERRED:
        label_2:
        while (true) {
          l = Deferred();
                                s.add(l);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NORMAL_DEFAULT:
          case ESCAPED_DEFAULT:
            l = Text();
                                s.add(l);
            break;
          default:
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case START_EVAL_DEFERRED:
            ;
            break;
          default:
            break label_2;
          }
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    jj_consume_token(0);
          {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Dynamic() throws ParseException, RunException {
                                                    MyLiteral e;
    jj_consume_token(START_EVAL_DYNAMIC);
    e = Expression();
    jj_consume_token(END_EVAL);
         if(e==null){
                {if (true) return new MyLiteral(Att.STRING);}
         }

         {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Deferred() throws ParseException, RunException {
                                                     MyLiteral e;
    jj_consume_token(START_EVAL_DEFERRED);
    e = Expression();
    jj_consume_token(END_EVAL);
         if(e==null){
                {if (true) return new MyLiteral();}
         }

         {if (true) return e.cast(Att.INT);}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Text() throws ParseException {
                             Token t = null; StringBuffer s = new StringBuffer();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ESCAPED_DEFAULT:
        t = jj_consume_token(ESCAPED_DEFAULT);
                                        s.append(t.image.substring(1));
        break;
      case NORMAL_DEFAULT:
        t = jj_consume_token(NORMAL_DEFAULT);
                                       s.append(t.image);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NORMAL_DEFAULT:
      case ESCAPED_DEFAULT:
        ;
        break;
      default:
        break label_3;
      }
    }
          {if (true) return new MyLiteral(s.toString());}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Expression() throws ParseException, RunException {
  MyLiteral n, a, b;
    n = Or();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QUESTION:
      jj_consume_token(QUESTION);
      a = Expression();
      jj_consume_token(COLON);
      b = Expression();
      {if (true) return n.getBoolean() ? a : b;}
      break;
    default:
      ;
    }
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Or() throws ParseException, RunException {
  MyLiteral l, r;
    l = And();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        break label_4;
      }
      jj_consume_token(OR);
      r = And();
      l = new MyLiteral(l.getBoolean() || r.getBoolean());
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral And() throws ParseException, RunException {
  MyLiteral l, r;
    l = Equality();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        break label_5;
      }
      jj_consume_token(AND);
      r = Equality();
      l = new MyLiteral(l.getBoolean() && r.getBoolean());
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Equality() throws ParseException, RunException {
  MyLiteral l, r;
    l = Compare();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
        r = Compare();
        l = new MyLiteral(l.equals(r));
        break;
      case NE:
        jj_consume_token(NE);
        r = Compare();
        l = new MyLiteral(!l.equals(r));
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Compare() throws ParseException, RunException {
  MyLiteral  l, r;
    l = Add();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GE:
      case LT:
      case LE:
        ;
        break;
      default:
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
        r = Add();
        l = new MyLiteral(l.compareTo(r) < 0);
        break;
      case GT:
        jj_consume_token(GT);
        r = Add();
        l = new MyLiteral(l.compareTo(r) > 0);
        break;
      case LE:
        jj_consume_token(LE);
        r = Add();
        l = new MyLiteral(l.compareTo(r) <= 0);
        break;
      case GE:
        jj_consume_token(GE);
        r = Add();
        l = new MyLiteral(l.compareTo(r) >= 0);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Add() throws ParseException, RunException {
  MyLiteral l, r;
    l = Mul();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
      case SUB:
        ;
        break;
      default:
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ADD:
        jj_consume_token(ADD);
        r = Mul();
        l = l.add(r);
        break;
      case SUB:
        jj_consume_token(SUB);
        r = Mul();
        l = l.sub(r);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Mul() throws ParseException, RunException {
  MyLiteral l, r;
    l = Unary();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIV:
      case MOD:
      case MUL:
      case UPPERCASE:
      case LOWERCASE:
      case CAPITALIZE:
        ;
        break;
      default:
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
        jj_consume_token(MUL);
        r = Unary();
        l = l.mul(r);
        break;
      case DIV:
        jj_consume_token(DIV);
        r = Unary();
        l = l.div(r);
        break;
      case MOD:
        jj_consume_token(MOD);
        r = Unary();
        l = l.mod(r);
        break;
      case UPPERCASE:
        jj_consume_token(UPPERCASE);
        r = Unary();
        l = l.upperCase(r);
        break;
      case LOWERCASE:
        jj_consume_token(LOWERCASE);
        r = Unary();
        l = l.lowerCase(r);
        break;
      case CAPITALIZE:
        jj_consume_token(CAPITALIZE);
        r = Unary();
        l = l.capitalize(r);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Unary() throws ParseException, RunException {
  MyLiteral n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUB:
      jj_consume_token(SUB);
      n = Unary();
    {if (true) return n.negate();}
      break;
    case NOT:
      jj_consume_token(NOT);
      n = Unary();
    {if (true) return n.not();}
      break;
    case EMPTY:
      jj_consume_token(EMPTY);
      n = Unary();
    {if (true) return n.isEmpty();}
      break;
    case INT:
      jj_consume_token(INT);
      n = Unary();
    {if (true) return new MyLiteral(n.getInt());}
      break;
    case LEN:
      jj_consume_token(LEN);
      n = Unary();
    {if (true) return n.len();}
      break;
    case TRNS:
      jj_consume_token(TRNS);
      n = Unary();
    {if (true) return trans(n);}
      break;
    case URLENCODE:
      jj_consume_token(URLENCODE);
      n = Unary();
    {if (true) return urlencode(n);}
      break;
    case MONEY:
      jj_consume_token(MONEY);
      n = Unary();
    {if (true) return money(n);}
      break;
    case INTEGER:
    case BOOLEAN:
    case FLOAT:
    case START_SSTRING:
    case START_DSTRING:
    case LPAREN:
    case NULL:
    case IDENTIFIER:
      n = Value();
    {if (true) return n;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Value() throws ParseException, RunException {
  Token t;
  MyLiteral n;
  String id;
  List propList=new ArrayList();
  List aList=new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      n = Expression();
      jj_consume_token(RPAREN);
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACK:
        case DOT:
          ;
          break;
        default:
          break label_10;
        }
        Property(propList, aList);
      }
                            if(propList.size() > 0)
                                n=getProperty(t.image,propList,aList);
                            else
                                n=getIdentifier(t.image);
      break;
    case INTEGER:
    case BOOLEAN:
    case FLOAT:
    case START_SSTRING:
    case START_DSTRING:
    case NULL:
      n = Literal();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final private void Property(List propList, List aList) throws ParseException, RunException {
        String p;
        Integer i;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      p = DotProperty();
    propList.add(p);
    aList.add(null);
      break;
    case LBRACK:
      i = BracketProperty();
    aList.add(i);
    propList.add(null);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private String DotProperty() throws ParseException {
  Token t = null;
    jj_consume_token(DOT);
    t = jj_consume_token(IDENTIFIER);
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final private Integer BracketProperty() throws ParseException, RunException {
  MyLiteral n;
    jj_consume_token(LBRACK);
    n = Expression();
    jj_consume_token(RBRACK);
    {if (true) return n.getInteger();}
    throw new Error("Missing return statement in function");
  }

  final private String Identifier() throws ParseException {
  Token t = null;
    t = jj_consume_token(IDENTIFIER);
    {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Literal() throws ParseException {
  MyLiteral n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      n = Boolean();
      break;
    case INTEGER:
      n = Integer();
      break;
    case FLOAT:
      n = Double();
      break;
    case START_SSTRING:
    case START_DSTRING:
      n = String();
      break;
    case NULL:
      jj_consume_token(NULL);
      n = null;
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Boolean() throws ParseException {
  Token t = null;
    t = jj_consume_token(BOOLEAN);
    {if (true) return new MyLiteral(Boolean.parseBoolean(t.image));}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Integer() throws ParseException {
  Token t = null;
    t = jj_consume_token(INTEGER);
    {if (true) return new MyLiteral(Integer.parseInt(t.image));}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral Double() throws ParseException {
  Token t = null;
    t = jj_consume_token(FLOAT);
    {if (true) return new MyLiteral(Double.parseDouble(t.image));}
    throw new Error("Missing return statement in function");
  }

  final private MyLiteral String() throws ParseException {
  String n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_SSTRING:
      n = SingleQuotedString();
    {if (true) return new MyLiteral(n);}
      break;
    case START_DSTRING:
      n = DoubleQuotedString();
    {if (true) return new MyLiteral(n);}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private String SingleQuotedString() throws ParseException {
  Token t = null;
  StringBuffer s = new StringBuffer();
    jj_consume_token(START_SSTRING);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NORMAL_SSTRING:
      case ESCAPED_SSTRING:
        ;
        break;
      default:
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NORMAL_SSTRING:
        t = jj_consume_token(NORMAL_SSTRING);
      s.append(t.image);
        break;
      case ESCAPED_SSTRING:
        t = jj_consume_token(ESCAPED_SSTRING);
      s.append(t.image.charAt(1));
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END_SSTRING);
    {if (true) return s.toString();}
    throw new Error("Missing return statement in function");
  }

  final private String DoubleQuotedString() throws ParseException {
  Token t = null;
  StringBuffer s = new StringBuffer();
    jj_consume_token(START_DSTRING);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NORMAL_DSTRING:
      case ESCAPED_DSTRING:
        ;
        break;
      default:
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NORMAL_DSTRING:
        t = jj_consume_token(NORMAL_DSTRING);
      s.append(t.image);
        break;
      case ESCAPED_DSTRING:
        t = jj_consume_token(ESCAPED_DSTRING);
      s.append(t.image.charAt(1));
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END_DSTRING);
    {if (true) return s.toString();}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public ExprRunnerTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;

  /** Constructor with user supplied CharStream. */
  public ExprRunner(CharStream stream) {
    token_source = new ExprRunnerTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Constructor with generated Token Manager. */
  public ExprRunner(ExprRunnerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(ExprRunnerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
